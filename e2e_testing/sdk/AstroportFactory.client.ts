/**
* This file was automatically generated by @cosmwasm/ts-codegen@1.12.1.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { CosmWasmClient, SigningCosmWasmClient, ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { Coin, StdFee } from "@cosmjs/amino";
import { PairType, InstantiateMsg, PairConfig, ExecuteMsg, AssetInfo, Addr, Binary, QueryMsg, ArrayOfPairType, ConfigResponse, FeeInfoResponse, PairInfo, ArrayOfPairInfo } from "./AstroportFactory.types";
export interface AstroportFactoryReadOnlyInterface {
  contractAddress: string;
  config: () => Promise<ConfigResponse>;
  pairsByAssetInfos: ({
    assetInfos,
    limit,
    startAfter
  }: {
    assetInfos: AssetInfo[];
    limit?: number;
    startAfter?: string;
  }) => Promise<ArrayOfPairInfo>;
  pairByLpToken: ({
    lpToken
  }: {
    lpToken: string;
  }) => Promise<PairInfo>;
  pairs: ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: string;
  }) => Promise<ArrayOfPairInfo>;
  feeInfo: ({
    pairType
  }: {
    pairType: PairType;
  }) => Promise<FeeInfoResponse>;
  blacklistedPairTypes: () => Promise<ArrayOfPairType>;
}
export class AstroportFactoryQueryClient implements AstroportFactoryReadOnlyInterface {
  client: CosmWasmClient;
  contractAddress: string;
  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.config = this.config.bind(this);
    this.pairsByAssetInfos = this.pairsByAssetInfos.bind(this);
    this.pairByLpToken = this.pairByLpToken.bind(this);
    this.pairs = this.pairs.bind(this);
    this.feeInfo = this.feeInfo.bind(this);
    this.blacklistedPairTypes = this.blacklistedPairTypes.bind(this);
  }
  config = async (): Promise<ConfigResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      config: {}
    });
  };
  pairsByAssetInfos = async ({
    assetInfos,
    limit,
    startAfter
  }: {
    assetInfos: AssetInfo[];
    limit?: number;
    startAfter?: string;
  }): Promise<ArrayOfPairInfo> => {
    return this.client.queryContractSmart(this.contractAddress, {
      pairs_by_asset_infos: {
        asset_infos: assetInfos,
        limit,
        start_after: startAfter
      }
    });
  };
  pairByLpToken = async ({
    lpToken
  }: {
    lpToken: string;
  }): Promise<PairInfo> => {
    return this.client.queryContractSmart(this.contractAddress, {
      pair_by_lp_token: {
        lp_token: lpToken
      }
    });
  };
  pairs = async ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: string;
  }): Promise<ArrayOfPairInfo> => {
    return this.client.queryContractSmart(this.contractAddress, {
      pairs: {
        limit,
        start_after: startAfter
      }
    });
  };
  feeInfo = async ({
    pairType
  }: {
    pairType: PairType;
  }): Promise<FeeInfoResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      fee_info: {
        pair_type: pairType
      }
    });
  };
  blacklistedPairTypes = async (): Promise<ArrayOfPairType> => {
    return this.client.queryContractSmart(this.contractAddress, {
      blacklisted_pair_types: {}
    });
  };
}
export interface AstroportFactoryInterface extends AstroportFactoryReadOnlyInterface {
  contractAddress: string;
  sender: string;
  updateConfig: ({
    coinRegistryAddress,
    feeAddress,
    incentivesAddress,
    tokenCodeId
  }: {
    coinRegistryAddress?: string;
    feeAddress?: string;
    incentivesAddress?: string;
    tokenCodeId?: number;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
  updatePairConfig: ({
    config
  }: {
    config: PairConfig;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
  createPair: ({
    assetInfos,
    initParams,
    pairType
  }: {
    assetInfos: AssetInfo[];
    initParams?: Binary;
    pairType: PairType;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
  proposeNewOwner: ({
    expiresIn,
    owner
  }: {
    expiresIn: number;
    owner: string;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
  dropOwnershipProposal: (fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
  claimOwnership: (fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
}
export class AstroportFactoryClient extends AstroportFactoryQueryClient implements AstroportFactoryInterface {
  client: SigningCosmWasmClient;
  sender: string;
  contractAddress: string;
  constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string) {
    super(client, contractAddress);
    this.client = client;
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.updateConfig = this.updateConfig.bind(this);
    this.updatePairConfig = this.updatePairConfig.bind(this);
    this.createPair = this.createPair.bind(this);
    this.proposeNewOwner = this.proposeNewOwner.bind(this);
    this.dropOwnershipProposal = this.dropOwnershipProposal.bind(this);
    this.claimOwnership = this.claimOwnership.bind(this);
  }
  updateConfig = async ({
    coinRegistryAddress,
    feeAddress,
    incentivesAddress,
    tokenCodeId
  }: {
    coinRegistryAddress?: string;
    feeAddress?: string;
    incentivesAddress?: string;
    tokenCodeId?: number;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_config: {
        coin_registry_address: coinRegistryAddress,
        fee_address: feeAddress,
        incentives_address: incentivesAddress,
        token_code_id: tokenCodeId
      }
    }, fee_, memo_, funds_);
  };
  updatePairConfig = async ({
    config
  }: {
    config: PairConfig;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_pair_config: {
        config
      }
    }, fee_, memo_, funds_);
  };
  createPair = async ({
    assetInfos,
    initParams,
    pairType
  }: {
    assetInfos: AssetInfo[];
    initParams?: Binary;
    pairType: PairType;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      create_pair: {
        asset_infos: assetInfos,
        init_params: initParams,
        pair_type: pairType
      }
    }, fee_, memo_, funds_);
  };
  proposeNewOwner = async ({
    expiresIn,
    owner
  }: {
    expiresIn: number;
    owner: string;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      propose_new_owner: {
        expires_in: expiresIn,
        owner
      }
    }, fee_, memo_, funds_);
  };
  dropOwnershipProposal = async (fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      drop_ownership_proposal: {}
    }, fee_, memo_, funds_);
  };
  claimOwnership = async (fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      claim_ownership: {}
    }, fee_, memo_, funds_);
  };
}