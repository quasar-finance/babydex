/**
* This file was automatically generated by @cosmwasm/ts-codegen@1.12.1.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { CosmWasmClient, SigningCosmWasmClient, ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { StdFee } from "@cosmjs/amino";
import { AssetInfo, Addr, Uint128, InstantiateMsg, IncentivizationFeeInfo, Coin, ExecuteMsg, Binary, Cw20ReceiveMsg, InputSchedule, Asset, QueryMsg, ArrayOfTupleOfStringAndUint128, ArrayOfAssetInfo, Config, Decimal256, ArrayOfScheduleResponse, ScheduleResponse, Boolean, ArrayOfString, ArrayOfAsset, RewardType, PoolInfoResponse, RewardInfo, ArrayOfRewardInfo } from "./AstroportIncentives.types";
export interface AstroportIncentivesReadOnlyInterface {
  contractAddress: string;
  config: () => Promise<Config>;
  queryDeposit: ({
    lpToken,
    user
  }: {
    lpToken: string;
    user: string;
  }) => Promise<Uint128>;
  pendingRewards: ({
    lpToken,
    user
  }: {
    lpToken: string;
    user: string;
  }) => Promise<ArrayOfAsset>;
  rewardInfo: ({
    lpToken
  }: {
    lpToken: string;
  }) => Promise<ArrayOfRewardInfo>;
  poolInfo: ({
    lpToken
  }: {
    lpToken: string;
  }) => Promise<PoolInfoResponse>;
  poolStakers: ({
    limit,
    lpToken,
    startAfter
  }: {
    limit?: number;
    lpToken: string;
    startAfter?: string;
  }) => Promise<ArrayOfTupleOfStringAndUint128>;
  blockedTokensList: ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: AssetInfo;
  }) => Promise<ArrayOfAssetInfo>;
  isFeeExpected: ({
    lpToken,
    reward
  }: {
    lpToken: string;
    reward: string;
  }) => Promise<Boolean>;
  externalRewardSchedules: ({
    limit,
    lpToken,
    reward,
    startAfter
  }: {
    limit?: number;
    lpToken: string;
    reward: string;
    startAfter?: number;
  }) => Promise<ArrayOfScheduleResponse>;
  listPools: ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: string;
  }) => Promise<ArrayOfString>;
  activePools: () => Promise<ArrayOfTupleOfStringAndUint128>;
}
export class AstroportIncentivesQueryClient implements AstroportIncentivesReadOnlyInterface {
  client: CosmWasmClient;
  contractAddress: string;
  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.config = this.config.bind(this);
    this.queryDeposit = this.queryDeposit.bind(this);
    this.pendingRewards = this.pendingRewards.bind(this);
    this.rewardInfo = this.rewardInfo.bind(this);
    this.poolInfo = this.poolInfo.bind(this);
    this.poolStakers = this.poolStakers.bind(this);
    this.blockedTokensList = this.blockedTokensList.bind(this);
    this.isFeeExpected = this.isFeeExpected.bind(this);
    this.externalRewardSchedules = this.externalRewardSchedules.bind(this);
    this.listPools = this.listPools.bind(this);
    this.activePools = this.activePools.bind(this);
  }
  config = async (): Promise<Config> => {
    return this.client.queryContractSmart(this.contractAddress, {
      config: {}
    });
  };
  queryDeposit = async ({
    lpToken,
    user
  }: {
    lpToken: string;
    user: string;
  }): Promise<Uint128> => {
    return this.client.queryContractSmart(this.contractAddress, {
      query_deposit: {
        lp_token: lpToken,
        user
      }
    });
  };
  pendingRewards = async ({
    lpToken,
    user
  }: {
    lpToken: string;
    user: string;
  }): Promise<ArrayOfAsset> => {
    return this.client.queryContractSmart(this.contractAddress, {
      pending_rewards: {
        lp_token: lpToken,
        user
      }
    });
  };
  rewardInfo = async ({
    lpToken
  }: {
    lpToken: string;
  }): Promise<ArrayOfRewardInfo> => {
    return this.client.queryContractSmart(this.contractAddress, {
      reward_info: {
        lp_token: lpToken
      }
    });
  };
  poolInfo = async ({
    lpToken
  }: {
    lpToken: string;
  }): Promise<PoolInfoResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      pool_info: {
        lp_token: lpToken
      }
    });
  };
  poolStakers = async ({
    limit,
    lpToken,
    startAfter
  }: {
    limit?: number;
    lpToken: string;
    startAfter?: string;
  }): Promise<ArrayOfTupleOfStringAndUint128> => {
    return this.client.queryContractSmart(this.contractAddress, {
      pool_stakers: {
        limit,
        lp_token: lpToken,
        start_after: startAfter
      }
    });
  };
  blockedTokensList = async ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: AssetInfo;
  }): Promise<ArrayOfAssetInfo> => {
    return this.client.queryContractSmart(this.contractAddress, {
      blocked_tokens_list: {
        limit,
        start_after: startAfter
      }
    });
  };
  isFeeExpected = async ({
    lpToken,
    reward
  }: {
    lpToken: string;
    reward: string;
  }): Promise<Boolean> => {
    return this.client.queryContractSmart(this.contractAddress, {
      is_fee_expected: {
        lp_token: lpToken,
        reward
      }
    });
  };
  externalRewardSchedules = async ({
    limit,
    lpToken,
    reward,
    startAfter
  }: {
    limit?: number;
    lpToken: string;
    reward: string;
    startAfter?: number;
  }): Promise<ArrayOfScheduleResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      external_reward_schedules: {
        limit,
        lp_token: lpToken,
        reward,
        start_after: startAfter
      }
    });
  };
  listPools = async ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: string;
  }): Promise<ArrayOfString> => {
    return this.client.queryContractSmart(this.contractAddress, {
      list_pools: {
        limit,
        start_after: startAfter
      }
    });
  };
  activePools = async (): Promise<ArrayOfTupleOfStringAndUint128> => {
    return this.client.queryContractSmart(this.contractAddress, {
      active_pools: {}
    });
  };
}
export interface AstroportIncentivesInterface extends AstroportIncentivesReadOnlyInterface {
  contractAddress: string;
  sender: string;
  setupPools: ({
    pools
  }: {
    pools: string[][];
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
  claimRewards: ({
    lpTokens
  }: {
    lpTokens: string[];
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
  receive: ({
    amount,
    msg,
    sender
  }: {
    amount: Uint128;
    msg: Binary;
    sender: string;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
  deposit: ({
    recipient
  }: {
    recipient?: string;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
  withdraw: ({
    amount,
    lpToken
  }: {
    amount: Uint128;
    lpToken: string;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
  setTokensPerSecond: ({
    amount
  }: {
    amount: Uint128;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
  incentivize: ({
    lpToken,
    schedule
  }: {
    lpToken: string;
    schedule: InputSchedule;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
  incentivizeMany: (fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
  removeRewardFromPool: ({
    bypassUpcomingSchedules,
    lpToken,
    receiver,
    reward
  }: {
    bypassUpcomingSchedules: boolean;
    lpToken: string;
    receiver: string;
    reward: string;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
  claimOrphanedRewards: ({
    limit,
    receiver
  }: {
    limit?: number;
    receiver: string;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
  updateConfig: ({
    astroToken,
    generatorController,
    guardian,
    incentivizationFeeInfo,
    tokenTransferGasLimit,
    vestingContract
  }: {
    astroToken?: AssetInfo;
    generatorController?: string;
    guardian?: string;
    incentivizationFeeInfo?: IncentivizationFeeInfo;
    tokenTransferGasLimit?: number;
    vestingContract?: string;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
  updateBlockedTokenslist: ({
    add,
    remove
  }: {
    add?: AssetInfo[];
    remove?: AssetInfo[];
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
  deactivatePool: ({
    lpToken
  }: {
    lpToken: string;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
  deactivateBlockedPools: (fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
  proposeNewOwner: ({
    expiresIn,
    owner
  }: {
    expiresIn: number;
    owner: string;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
  dropOwnershipProposal: (fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
  claimOwnership: (fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
}
export class AstroportIncentivesClient extends AstroportIncentivesQueryClient implements AstroportIncentivesInterface {
  client: SigningCosmWasmClient;
  sender: string;
  contractAddress: string;
  constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string) {
    super(client, contractAddress);
    this.client = client;
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.setupPools = this.setupPools.bind(this);
    this.claimRewards = this.claimRewards.bind(this);
    this.receive = this.receive.bind(this);
    this.deposit = this.deposit.bind(this);
    this.withdraw = this.withdraw.bind(this);
    this.setTokensPerSecond = this.setTokensPerSecond.bind(this);
    this.incentivize = this.incentivize.bind(this);
    this.incentivizeMany = this.incentivizeMany.bind(this);
    this.removeRewardFromPool = this.removeRewardFromPool.bind(this);
    this.claimOrphanedRewards = this.claimOrphanedRewards.bind(this);
    this.updateConfig = this.updateConfig.bind(this);
    this.updateBlockedTokenslist = this.updateBlockedTokenslist.bind(this);
    this.deactivatePool = this.deactivatePool.bind(this);
    this.deactivateBlockedPools = this.deactivateBlockedPools.bind(this);
    this.proposeNewOwner = this.proposeNewOwner.bind(this);
    this.dropOwnershipProposal = this.dropOwnershipProposal.bind(this);
    this.claimOwnership = this.claimOwnership.bind(this);
  }
  setupPools = async ({
    pools
  }: {
    pools: string[][];
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      setup_pools: {
        pools
      }
    }, fee_, memo_, funds_);
  };
  claimRewards = async ({
    lpTokens
  }: {
    lpTokens: string[];
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      claim_rewards: {
        lp_tokens: lpTokens
      }
    }, fee_, memo_, funds_);
  };
  receive = async ({
    amount,
    msg,
    sender
  }: {
    amount: Uint128;
    msg: Binary;
    sender: string;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      receive: {
        amount,
        msg,
        sender
      }
    }, fee_, memo_, funds_);
  };
  deposit = async ({
    recipient
  }: {
    recipient?: string;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      deposit: {
        recipient
      }
    }, fee_, memo_, funds_);
  };
  withdraw = async ({
    amount,
    lpToken
  }: {
    amount: Uint128;
    lpToken: string;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      withdraw: {
        amount,
        lp_token: lpToken
      }
    }, fee_, memo_, funds_);
  };
  setTokensPerSecond = async ({
    amount
  }: {
    amount: Uint128;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      set_tokens_per_second: {
        amount
      }
    }, fee_, memo_, funds_);
  };
  incentivize = async ({
    lpToken,
    schedule
  }: {
    lpToken: string;
    schedule: InputSchedule;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      incentivize: {
        lp_token: lpToken,
        schedule
      }
    }, fee_, memo_, funds_);
  };
  incentivizeMany = async (fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      incentivize_many: {}
    }, fee_, memo_, funds_);
  };
  removeRewardFromPool = async ({
    bypassUpcomingSchedules,
    lpToken,
    receiver,
    reward
  }: {
    bypassUpcomingSchedules: boolean;
    lpToken: string;
    receiver: string;
    reward: string;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      remove_reward_from_pool: {
        bypass_upcoming_schedules: bypassUpcomingSchedules,
        lp_token: lpToken,
        receiver,
        reward
      }
    }, fee_, memo_, funds_);
  };
  claimOrphanedRewards = async ({
    limit,
    receiver
  }: {
    limit?: number;
    receiver: string;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      claim_orphaned_rewards: {
        limit,
        receiver
      }
    }, fee_, memo_, funds_);
  };
  updateConfig = async ({
    astroToken,
    generatorController,
    guardian,
    incentivizationFeeInfo,
    tokenTransferGasLimit,
    vestingContract
  }: {
    astroToken?: AssetInfo;
    generatorController?: string;
    guardian?: string;
    incentivizationFeeInfo?: IncentivizationFeeInfo;
    tokenTransferGasLimit?: number;
    vestingContract?: string;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_config: {
        astro_token: astroToken,
        generator_controller: generatorController,
        guardian,
        incentivization_fee_info: incentivizationFeeInfo,
        token_transfer_gas_limit: tokenTransferGasLimit,
        vesting_contract: vestingContract
      }
    }, fee_, memo_, funds_);
  };
  updateBlockedTokenslist = async ({
    add,
    remove
  }: {
    add?: AssetInfo[];
    remove?: AssetInfo[];
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_blocked_tokenslist: {
        add,
        remove
      }
    }, fee_, memo_, funds_);
  };
  deactivatePool = async ({
    lpToken
  }: {
    lpToken: string;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      deactivate_pool: {
        lp_token: lpToken
      }
    }, fee_, memo_, funds_);
  };
  deactivateBlockedPools = async (fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      deactivate_blocked_pools: {}
    }, fee_, memo_, funds_);
  };
  proposeNewOwner = async ({
    expiresIn,
    owner
  }: {
    expiresIn: number;
    owner: string;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      propose_new_owner: {
        expires_in: expiresIn,
        owner
      }
    }, fee_, memo_, funds_);
  };
  dropOwnershipProposal = async (fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      drop_ownership_proposal: {}
    }, fee_, memo_, funds_);
  };
  claimOwnership = async (fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      claim_ownership: {}
    }, fee_, memo_, funds_);
  };
}