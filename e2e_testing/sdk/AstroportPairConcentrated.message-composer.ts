/**
* This file was automatically generated by @cosmwasm/ts-codegen@1.12.1.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { Coin } from "@cosmjs/amino";
import { MsgExecuteContractEncodeObject } from "@cosmjs/cosmwasm-stargate";
import { MsgExecuteContract } from "cosmjs-types/cosmwasm/wasm/v1/tx";
import { toUtf8 } from "@cosmjs/encoding";
import { AssetInfo, Addr, Binary, PairType, InstantiateMsg, ExecuteMsg, Uint128, Decimal, Cw20ReceiveMsg, Asset, QueryMsg, Decimal256, ConfigResponse, CumulativePricesResponse, PairInfo, PoolResponse, ReverseSimulationResponse, ArrayOfAsset, SimulationResponse } from "./AstroportPairConcentrated.types";
export interface AstroportPairConcentratedMsg {
  contractAddress: string;
  sender: string;
  receive: ({
    amount,
    msg,
    sender
  }: {
    amount: Uint128;
    msg: Binary;
    sender: string;
  }, funds_?: Coin[]) => MsgExecuteContractEncodeObject;
  provideLiquidity: ({
    assets,
    autoStake,
    minLpToReceive,
    receiver,
    slippageTolerance
  }: {
    assets: Asset[];
    autoStake?: boolean;
    minLpToReceive?: Uint128;
    receiver?: string;
    slippageTolerance?: Decimal;
  }, funds_?: Coin[]) => MsgExecuteContractEncodeObject;
  swap: ({
    askAssetInfo,
    beliefPrice,
    maxSpread,
    offerAsset,
    to
  }: {
    askAssetInfo?: AssetInfo;
    beliefPrice?: Decimal;
    maxSpread?: Decimal;
    offerAsset: Asset;
    to?: string;
  }, funds_?: Coin[]) => MsgExecuteContractEncodeObject;
  updateConfig: ({
    params
  }: {
    params: Binary;
  }, funds_?: Coin[]) => MsgExecuteContractEncodeObject;
  proposeNewOwner: ({
    expiresIn,
    owner
  }: {
    expiresIn: number;
    owner: string;
  }, funds_?: Coin[]) => MsgExecuteContractEncodeObject;
  dropOwnershipProposal: (funds_?: Coin[]) => MsgExecuteContractEncodeObject;
  claimOwnership: (funds_?: Coin[]) => MsgExecuteContractEncodeObject;
}
export class AstroportPairConcentratedMsgComposer implements AstroportPairConcentratedMsg {
  sender: string;
  contractAddress: string;
  constructor(sender: string, contractAddress: string) {
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.receive = this.receive.bind(this);
    this.provideLiquidity = this.provideLiquidity.bind(this);
    this.swap = this.swap.bind(this);
    this.updateConfig = this.updateConfig.bind(this);
    this.proposeNewOwner = this.proposeNewOwner.bind(this);
    this.dropOwnershipProposal = this.dropOwnershipProposal.bind(this);
    this.claimOwnership = this.claimOwnership.bind(this);
  }
  receive = ({
    amount,
    msg,
    sender
  }: {
    amount: Uint128;
    msg: Binary;
    sender: string;
  }, funds_?: Coin[]): MsgExecuteContractEncodeObject => {
    return {
      typeUrl: "/cosmwasm.wasm.v1.MsgExecuteContract",
      value: MsgExecuteContract.fromPartial({
        sender: this.sender,
        contract: this.contractAddress,
        msg: toUtf8(JSON.stringify({
          receive: {
            amount,
            msg,
            sender
          }
        })),
        funds: funds_
      })
    };
  };
  provideLiquidity = ({
    assets,
    autoStake,
    minLpToReceive,
    receiver,
    slippageTolerance
  }: {
    assets: Asset[];
    autoStake?: boolean;
    minLpToReceive?: Uint128;
    receiver?: string;
    slippageTolerance?: Decimal;
  }, funds_?: Coin[]): MsgExecuteContractEncodeObject => {
    return {
      typeUrl: "/cosmwasm.wasm.v1.MsgExecuteContract",
      value: MsgExecuteContract.fromPartial({
        sender: this.sender,
        contract: this.contractAddress,
        msg: toUtf8(JSON.stringify({
          provide_liquidity: {
            assets,
            auto_stake: autoStake,
            min_lp_to_receive: minLpToReceive,
            receiver,
            slippage_tolerance: slippageTolerance
          }
        })),
        funds: funds_
      })
    };
  };
  swap = ({
    askAssetInfo,
    beliefPrice,
    maxSpread,
    offerAsset,
    to
  }: {
    askAssetInfo?: AssetInfo;
    beliefPrice?: Decimal;
    maxSpread?: Decimal;
    offerAsset: Asset;
    to?: string;
  }, funds_?: Coin[]): MsgExecuteContractEncodeObject => {
    return {
      typeUrl: "/cosmwasm.wasm.v1.MsgExecuteContract",
      value: MsgExecuteContract.fromPartial({
        sender: this.sender,
        contract: this.contractAddress,
        msg: toUtf8(JSON.stringify({
          swap: {
            ask_asset_info: askAssetInfo,
            belief_price: beliefPrice,
            max_spread: maxSpread,
            offer_asset: offerAsset,
            to
          }
        })),
        funds: funds_
      })
    };
  };
  updateConfig = ({
    params
  }: {
    params: Binary;
  }, funds_?: Coin[]): MsgExecuteContractEncodeObject => {
    return {
      typeUrl: "/cosmwasm.wasm.v1.MsgExecuteContract",
      value: MsgExecuteContract.fromPartial({
        sender: this.sender,
        contract: this.contractAddress,
        msg: toUtf8(JSON.stringify({
          update_config: {
            params
          }
        })),
        funds: funds_
      })
    };
  };
  proposeNewOwner = ({
    expiresIn,
    owner
  }: {
    expiresIn: number;
    owner: string;
  }, funds_?: Coin[]): MsgExecuteContractEncodeObject => {
    return {
      typeUrl: "/cosmwasm.wasm.v1.MsgExecuteContract",
      value: MsgExecuteContract.fromPartial({
        sender: this.sender,
        contract: this.contractAddress,
        msg: toUtf8(JSON.stringify({
          propose_new_owner: {
            expires_in: expiresIn,
            owner
          }
        })),
        funds: funds_
      })
    };
  };
  dropOwnershipProposal = (funds_?: Coin[]): MsgExecuteContractEncodeObject => {
    return {
      typeUrl: "/cosmwasm.wasm.v1.MsgExecuteContract",
      value: MsgExecuteContract.fromPartial({
        sender: this.sender,
        contract: this.contractAddress,
        msg: toUtf8(JSON.stringify({
          drop_ownership_proposal: {}
        })),
        funds: funds_
      })
    };
  };
  claimOwnership = (funds_?: Coin[]): MsgExecuteContractEncodeObject => {
    return {
      typeUrl: "/cosmwasm.wasm.v1.MsgExecuteContract",
      value: MsgExecuteContract.fromPartial({
        sender: this.sender,
        contract: this.contractAddress,
        msg: toUtf8(JSON.stringify({
          claim_ownership: {}
        })),
        funds: funds_
      })
    };
  };
}